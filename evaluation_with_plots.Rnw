%!TEX root = paper.tex
<<knitr-load, echo=FALSE, include=FALSE>>=
if (Sys.getenv("RSTUDIO") == "1") {
    setwd("/home/sopi/Documents/Side_projects/behaviour-analysis/")
} else {
   opts_chunk$set(
    fig.path="./figure/",
    fig.keep='all',
    dev=c('tikz'), #dev='pdf',c('tikz', 'svg'),
    dev.args=list(pointsize=8, timestamp = FALSE),
    echo=FALSE,
    external=FALSE,
    tidy=FALSE)

  ## Make sure that TikZDevice is used for measuring size of latex labels
  options(device = function(...) tikzDevice::tikz(tempfile(), ...))
}

#install.packages("reshape2", repos='http://cran.us.r-project.org')
#install.packages("htmlTable", repos='http://cran.us.r-project.org')
#install.packages("networkD3", repos='http://cran.us.r-project.org')
#install.packages("testit", repos='http://cran.us.r-project.org')
library(reshape2)
library(ggplot2)
library(data.table)
library(dplyr)
library(stringr)
library(xtable)
library(htmlTable)
library(networkD3)
library(R.utils)
library(assertr)
library(testit)


source("./scripts/libraries.R", chdir=TRUE)
source("./scripts/paper.R", chdir=TRUE)
source("./scripts/phase-data-processing.R", chdir=TRUE)
source("./scripts/machine_specs.R", chdir=TRUE)

data <- read_splitting_profiling_file("./latest/parsed_BlogRailsRoutes.mylog")

############################################## READ-ME ##############################################
# INVARIANTS TO BE CHECKED
# 1- A call-site is identified by a unique pair: {Source.Section, Symbol}
# 2- A target is identified by a unique triple: {Source.Section, Symbol, Receiver}
# 3- For one call-site, the number of original receivers is necessarily greater or equal to the number of observed receivers
# 4- There is at least one target per call-site (so the number of targets >= number of call-sites)

# COLUMN DESCRIPTION
# Source.Section - the lexical location of the call. This is somewhat not 100% reliable, so we pair it with:
# Symbol - the name of the symbol at this location, to turn it into a unique identifier for the location
# CT.Address - the hashcode of the target executed at this call-site. Needed to spot whether splitting happened
# Original.Receiver - class of the receiver of this call, before lookup (could later resolve higher in its class hierarchy)
# Observed.Receiver - class of the receiver of this call, after lookup 

# VARIABLE DESCRIPTION
# Num.Call.Sites - The number of call-sites executed in this run (as in number of distinct pair of Source.Section, Symbol)
# Num.Targets.Original - The total number of different call-targets in this run (before lookup)
# Num.Targets.Observed - The total number of different call-targets in this run (after lookup)

############################################## MAIN TABLE ############################################## 

# remove any invalid data (extra logging info ignored by parsing)
# TODO - improve parser
data <- data %>% 
    dplyr::filter(!(Source.Section=="")) %>% 
    tibble::rowid_to_column(var="Call.ID")

# Add info on the number of call targets per call-site (taking splittng into account)
# Add: Num.Receiver.Observed, Num.Receiver.Original
total_w_splitting <- data %>%
  group_by(Source.Section, Symbol, CT.Address) %>%
  dplyr::mutate(Num.Receiver.Observed = n_distinct(Observed.Receiver)) %>%
  dplyr::mutate(Num.Receiver.Original = n_distinct(Original.Receiver)) %>%
  verify(Num.Receiver.Original >= Num.Receiver.Observed) %>% # Assert invariant 3
  ungroup() 

total_wo_splitting <- data %>%
  group_by(Source.Section, Symbol) %>%
  dplyr::mutate(Num.Receiver.Observed = n_distinct(Observed.Receiver)) %>%
  dplyr::mutate(Num.Receiver.Original = n_distinct(Original.Receiver)) %>%
  # Invariant 3 cannot be verified in this case
  ungroup() 

############################################## VARIABLES ############################################## 
# Mainly used for latex macro and checking invariants

Num.Call.Sites <- n_distinct(data$Source.Section, data$Symbol) 
Num.Call.Sites.Incl.Splitted <- n_distinct(data$Source.Section, data$Symbol, data$CT.Address) 
Num.Targets.Original <- n_distinct(total_w_splitting$Source.Section, total_w_splitting$Symbol, total_w_splitting$Num.Receiver.Original) 
Num.Targets.Observed <- n_distinct(total_w_splitting$Source.Section, total_w_splitting$Symbol, total_w_splitting$Num.Receiver.Observed) 
assert("There should not be more call-sites than call targets", Num.Targets.Original >= Num.Call.Sites) # assert invariant 4
assert("There should not be more call-sites than splitted call sites", Num.Call.Sites.Incl.Splitted >= Num.Call.Sites) 

############################################## POLYMORPHISM ##############################################

#' Return a data frame that summarises polymoprhic behaviour in this run
# Add: Num.Call.Sites (the number of call-sites associated with a given number of receivers), Cumulative
#' @param num_receiver_column, whether we consider the observed or the original number of receivers  
#' @param ct_address, whether we consider splitting 
compute_num_target <- function(data, num_receiver_column) {
  df <- data %>%
    select(Source.Section, Symbol, !! sym(num_receiver_column)) %>% 
    group_by(Source.Section, Symbol) %>%
    filter(row_number()==1) %>% # at this point, we have a line per call-site
    group_by(!! sym(num_receiver_column)) %>%
    dplyr::mutate("Num.Call.Sites" = n_distinct(Source.Section, Symbol)) %>%
    select(!! sym(num_receiver_column), Num.Call.Sites) %>%
    filter(row_number()==1) %>% #just keep the first of each source section
    mutate(Cumulative = rev(cumsum(rev(Num.Call.Sites))))
  return(df)
}

num_target_original <- compute_num_target(total_wo_splitting, "Num.Receiver.Original")
num_target_observed <- compute_num_target(total_wo_splitting, "Num.Receiver.Observed")
assert("Both tables should have the same number of call-sites", first(num_target_original$Cumulative) == first(num_target_observed$Cumulative))
assert("... And it should match the total number of call-sites", first(num_target_original$Cumulative) == Num.Call.Sites)

#' Return a data frame that summarises polymoprhic behaviour in this run, takes splitting into account
# Add: Num.Call.Sites (the number of call-sites associated with a given number of receivers), Cumulative
#' @param num_receiver_column, whether we consider the observed or the original number of receivers  
#' @param ct_address, whether we consider splitting 
compute_num_target_splitting <- function(data, num_receiver_column) {
  df <- data %>%
    select(Source.Section, Symbol, CT.Address, !! sym(num_receiver_column)) %>% 
    group_by(Source.Section, Symbol, CT.Address) %>%
    filter(row_number()==1) %>% # at this point, we have a line per call-site
    group_by(!! sym(num_receiver_column)) %>%
    dplyr::mutate("Num.Call.Sites" = n_distinct(Source.Section, Symbol, CT.Address)) %>%
    select(!! sym(num_receiver_column), Num.Call.Sites) %>%
    filter(row_number()==1) %>% #just keep the first of each source section
    mutate(Cumulative = rev(cumsum(rev(Num.Call.Sites))))
  return(df)
}

num_target_original_w_splitting <- compute_num_target_splitting(total_w_splitting, "Num.Receiver.Original")
num_target_observed_w_splitting <- compute_num_target_splitting(total_w_splitting, "Num.Receiver.Observed")
assert("Both tables should have the same number of call-sites", first(num_target_original_w_splitting$Cumulative) == first(num_target_observed_w_splitting$Cumulative))
assert("... And it should match the total number of call-sites", first(num_target_original_w_splitting$Cumulative) == Num.Call.Sites.Incl.Splitted)

# Add the cache type for each call-site
total_w_splitting <- total_w_splitting %>%
  group_by(Source.Section, Symbol, CT.Address) %>%
  dplyr::mutate(Cache.Type.Original = case_when(Num.Targets.Original == 1 ~ "MONO",
                                       Num.Targets.Original > 1 && Num.Targets.Original <= 8 ~ "POLY",
                                       Num.Targets.Original > 8 ~ "MEGA"))%>%
  dplyr::mutate(Cache.Type.Observed = case_when(Num.Targets.Observed == 1 ~ "MONO",
                                       Num.Targets.Observed > 1 && Num.Targets.Observed <= 8 ~ "POLY",
                                       Num.Targets.Observed > 8 ~ "MEGA")) 




############################################## TARGET POLYMORPHISM ##############################################

total_w_splitting <- total_w_splitting %>%
  dplyr::mutate(Target.Polymorphism = (Observed.Receiver != Original.Receiver))

total_w_splitting <- total_w_splitting %>%
  group_by(Source.Section, Symbol, CT.Address) %>%
  dplyr::mutate(Has.Changed.Status = (Cache.Type.Observed != Cache.Type.Original)) %>%
  dplyr::mutate(Final.Status = any(str_detect(Has.Changed.Status, 'TRUE'))) %>%
  dplyr::mutate(Final.TP = any(str_detect(Target.Polymorphism, 'TRUE'))) %>%
  dplyr::mutate(Invalid.Status = case_when(Cache.Type.Original == "MONO" && Num.Targets.Observed == "POLY" ~ 'TRUE',
                                           Cache.Type.Original == "MONO" && Num.Targets.Observed == "MEGA" ~ 'TRUE',
                                           Cache.Type.Original == "POLY" && Num.Targets.Observed == "MEGA" ~ 'TRUE')) 

assert("Changes of cache status are only allowed from high degree of polymoprhism to low degree of polymoprhism", nrow(total_w_splitting %>%  dplyr::filter(grepl('TRUE', Invalid.Status))) == 0)


########################################################################################################
############################################## MANUAL INSPECTION ############################################## 
########################################################################################################

# to filter out by the number of targets and only keep polymoprhic call-sites (useful for later manual inspection)
polymorphic_call_sites <- total %>%
  filter(Num.Targets.Observed >= 2) %>%
  filter(Num.Targets.Original >= 2)

# distribution for each call site, pick the most represented receiver by call-site
# TODO - I think this is overly too complex
distrib_per_call_site <- polymorphic_call_sites %>%
  group_by(Source.Section, Symbol, CT.Address, Receiver) %>%
  dplyr::summarise(n_calls = n()) %>%
  dplyr::mutate(Weight.Frequent.Receiver = round(n_calls/sum(n_calls),3)*100) %>%
  dplyr::arrange(desc(n_calls)) %>%
  group_by(Source.Section) %>%
  dplyr::mutate(Num.Calls.Per.SS = sum(n_calls)) %>%
  dplyr::mutate(Times.splitted = n_distinct(CT.Address)) %>%
  dplyr::arrange(desc(Num.Calls.Per.SS),  CT.Address, Source.Section, desc(n_calls)) 

# Selection of most optimizable poly|megamorphic call sites (lots of calls)
table_optimizable <- distrib_per_call_site %>%
  group_by(Source.Section) %>%
  filter(row_number()==1) %>% #just keep the first of each source section
  tibble::rowid_to_column(var="Rank")
table_optimizable_aux <- data.frame(table_optimizable)
table_optimizable_aux$Source.Section <- str_trunc(table_optimizable_aux$Source.Section, 25, "center") #truncate the receiver label just so it fits on the table

table_optimizable_builtin <- table_optimizable %>%
    filter(Source.Section == "(core):1:1:0")
table_optimizable_builtin <- data.frame(table_optimizable_builtin)

table_optimizable_no_builtin <- table_optimizable %>%
  filter(Source.Section != "(core):1:1:0")
table_optimizable_no_builtin <- data.frame(table_optimizable_no_builtin)
# data <- data %>%
#   group_by(Source.Section) %>%
#   dplyr::filter(!(Source.Section=="")) %>% 
#   dplyr::mutate(Num.Symbols = n_distinct(Symbol)) %>%
#   dplyr::mutate(Different.Symbol = case_when(Num.Symbols >1 ~ TRUE,
#                                              Num.Symbols == 1 ~FALSE)) %>%
#   dplyr::filter(Different.Symbol == TRUE) %>%
#   group_by(Source.Section)








# to get an idea of the most executed call-sites
most_executed <- total %>%
  group_by(Source.Section, Receiver, Symbol) %>%
  dplyr::summarise(Num.Calls = n()) %>%
  dplyr::arrange(desc(Num.Calls))
most_executed$Receiver <- str_trunc(most_executed$Receiver, 25, "center") #truncate the receiver label just so it fits on the table

# number of split per call site
split_call_site <- total %>%
  group_by(Source.Section) %>%
  dplyr::summarise(Times.splitted = n_distinct(CT.Address)) %>%
  #dplyr::select(Source.Section, Receiver, Symbol, Times.splitted) %>%
  dplyr::arrange(desc(Times.splitted))
split_call_site$Source.Section <- str_trunc(split_call_site$Source.Section, 25, "center")

split_call_site_more <- split_call_site %>%
    filter(Times.splitted > 1)

############################################## TARGET POLYMORPHISM ############################################## 

# how many call-sites are experiencing target polymoprhism?
total <- total %>%
  dplyr::mutate(Target.Polymorphism = (Observed.Receiver != Original.Receiver))

target_poly <- total %>%
  group_by(Source.Section, Symbol, CT.Address) %>%
  dplyr::mutate(Cache.Type.Original = case_when(Num.Targets.Original == 1 ~ "MONO",
                                       Num.Targets.Original > 1 && Num.Targets.Original <= 8 ~ "POLY",
                                       Num.Targets.Original > 8 ~ "MEGA"))%>%
  dplyr::mutate(Cache.Type.Observed = case_when(Num.Targets.Observed == 1 ~ "MONO",
                                       Num.Targets.Observed > 1 && Num.Targets.Observed <= 8 ~ "POLY",
                                       Num.Targets.Observed > 8 ~ "MEGA")) %>%
  dplyr::mutate(Has.Changed.Status = (Cache.Type.Observed != Cache.Type.Original)) %>%
  dplyr::mutate(Final.Status = any(str_detect(Has.Changed.Status, 'TRUE'))) %>%
  dplyr::mutate(Final.TP = any(str_detect(Target.Polymorphism, 'TRUE')))

details <- target_poly %>% group_by(Source.Section, Symbol, CT.Address) %>%  filter(Final.Status == TRUE) %>%  filter(Final.TP == TRUE)

# How many source sections (call-sites) are changing LC status due to TP?
Num.Call.Sites <- target_poly %>% group_by(Source.Section, Symbol, CT.Address) %>% length(.)
Has.Experienced.TP <- nrow(target_poly %>% group_by(Source.Section, Symbol, CT.Address) %>% slice(1) %>% filter(Final.TP == TRUE)) 
Has.Changed.Status <- nrow(target_poly %>% group_by(Source.Section, Symbol, CT.Address) %>% slice(1) %>% filter(Final.Status == TRUE)) 


############################################## TABLE GENERATION ############################################## 

distrib_ct_table <- xtable(data_summary_num_targets_original, caption = "Distribution of call-targets")
distrib_ct_table <- autoformat(distrib_ct_table, zap = getOption("digits"))

hottest_mega_ct_table <- xtable(table_optimizable_aux, caption = "Hottest megamorphic call sites")
hottest_mega_ct_table <- autoformat(hottest_mega_ct_table, zap = getOption("digits"))

hottest_30mega_ct_table <- xtable(head(table_optimizable_aux,30), caption = "Hottest megamorphic call sites")
hottest_30mega_ct_table <- autoformat(hottest_30mega_ct_table, zap = getOption("digits"))

distrib_split_per_ct_table <- xtable(split_call_site, caption = "Distribution of splits per target")
distrib_split_per_ct_table <- autoformat(distrib_split_per_ct_table, zap = getOption("digits"))

distrib_2plus_split_per_ct_table <- xtable(split_call_site_more, caption = "Distribution of splits per target")
distrib_2plus_split_per_ct_table <- autoformat(distrib_2plus_split_per_ct_table, zap = getOption("digits"))

most_executed <- xtable(head(most_executed, 35), caption = "Most executed call-sites")
most_executed <- autoformat(most_executed, zap = getOption("digits"))


############################################## SUMMARY TABLE GENERATION ACCORDING TO CACHE TYPE ############################################## 

total_per_cache_type <- target_poly %>%
  group_by(Cache.Type.Original) %>%
  dplyr::summarise(Num.Calls = n(), Num.Call.Sites = n_distinct(Source.Section, Symbol), Times.splitted = n_distinct(CT.Address))

cachetab <- xtable(total_per_cache_type, caption = "Summary per cache type")
cachetab <- autoformat(cachetab, zap = getOption("digits"))

############################################## SUMMARY TABLE GENERATION ACCORDING TO CALL TYPE ############################################## 

total_per_call_type <- total %>%
  group_by(Builtin.) %>%
  dplyr::summarise(Num.Calls = n(), Num.Call.Sites = n_distinct(Source.Section), Times.splitted = n_distinct(CT.Address))

calltab <- xtable(total_per_call_type, caption = "Summary per call type")
calltab <- autoformat(calltab, zap = getOption("digits"))

############################################## PLOT GENERATION - FACET ##############################################

plot_calls <- function(ss, rec) {
  filtered_data <- filtered %>% filter(Source.Section == ss)
p <- ggplot(data = filtered_data, aes(x=as.numeric(as.character(Call.ID)), y=Receiver, color=Receiver)) + geom_point(size = 0.5, alpha = 0.4) 
p <- p + facet_wrap( ~CT.Address, scales = "free", ncol = 3) + xlab("Call ID") + ylab("Target") + theme(legend.position = "none") + ggtitle(paste("Selector: ",filtered_data$Symbol, ", in source: ", filtered_data$Source.Section))
    p <- p + theme(text = element_text(size=10)) 
 return (p)
}

f <- function(row) {
  ss <- row['Source.Section']
  rec <- row['Receiver']
  rank <- row['Rank']
  p_ <- plot_calls(ss, rec)
  ss <- gsub("*/","_",ss) # replace the / in the name otherwise the file cannot be created
  ggsave(p_, path=now, filename=paste(rank,"_",ss,"_plot.png", sep=""), height = 300, width = 500, units="mm")
}

# create the directory
now <- format(Sys.time(), "%b%d-%Y_%X")
now <- paste("results",now,sep="/")
dir.create(now)

# if there are no polymorphic call-sites, no need to generate those graphs 
# WIP - supposed to exclude primitive call, be not great
if (nrow(filtered) != 0) {
apply(head(table_optimizable_no_builtin, 30), 1, f) 
}

# this folder is now hlding the latest ran analysis
createLink(link="latest", target=now, overwrite=TRUE)

############################################## PLOT GENERATION - ##############################################

plot_calls_sub <- function(ss) {
  filtered_data <- filtered %>% filter(Source.Section == ss)
  dir_name = paste(now,ss,sep="/")
  dir.create(dir_name)
  for (addr in unique(filtered_data$CT.Address)) {
    filtered_data_addr <- filtered %>% filter(Source.Section == ss) %>% filter(CT.Address == addr) 
    p <- ggplot(data = filtered_data_addr, aes(x=as.numeric(as.character(Call.ID)), y=Receiver, color=Receiver)) + geom_point(size = 0.5, alpha = 0.4) 
    p <- p  + xlab("Call ID") + ylab("Target") + theme(legend.position = "none") + ggtitle(paste("Selector: ",filtered_data_addr$Symbol, ", in source: ", filtered_data_addr$Source.Section))
    p <- p + theme(text = element_text(size=15)) 
    ss <- gsub("*/","_",ss)
    ggsave(p, path=dir_name, filename=paste(addr,"_",ss,"_plot.png", sep=""), height = 300, width = 500, units="mm")
  }
  return (ss)
}

f_subdir <- function(row) {
  ss <- row['Source.Section']
  rec <- row['Receiver']
  rank <- row['Rank']
  o <- plot_calls_sub(ss)
}

# WIP - supposed to exclude primitive call, be not great
apply(head(table_optimizable_no_builtin,30), 1, f_subdir) 

############################################## VARIBALES GENERATION ##############################################

num_call_sites <- data_summary_num_targets %>% filter(Num.Targets == 1)
num_poly <- data_summary_num_targets %>% filter(Num.Targets >= 2 && Num.Targets < 9)
num_mega <- data_summary_num_targets %>% filter(Num.Targets >= 9)

is.integer0 <- function(x)
{
  return (is.integer(x) && length(x) == 0L)
}

if (is.integer0(num_poly$Cumulative)) {
   num_poly <- 0
} else {
  num_poly <- head(num_poly$Cumulative,1)
}

if (is.integer0(num_mega$Cumulative)) {
  num_mega <- 0
} else{
  num_mega <- head(num_mega$Cumulative,1)
}

############################################## TABLE SAVING ##############################################

table_folder <- paste(now,"summary_tables",sep="/")
dir.create(table_folder)
print(xtable(distrib_ct_table, type = "latex"), include.rownames=FALSE, tabular.environment="longtable",floating=FALSE, file = paste(table_folder,"call_target_distrib.tex", sep="/"))
print(xtable(hottest_mega_ct_table, type = "latex"), include.rownames=FALSE, file = paste(table_folder,"hottest_megamorphic_call_sites.tex", sep="/"))
print(xtable(distrib_split_per_ct_table, type = "latex"), include.rownames=FALSE, tabular.environment="longtable",floating=FALSE, file = paste(table_folder,"splits_per_target.tex", sep="/"))


############################################## LATEX COMMAND GENERATION ##############################################

@
\def\CallTargetDistrib{%
<<calltarget, echo=FALSE, results='asis'>>=
print(xtable(distrib_ct_table, type = "latex"), include.rownames=FALSE, tabular.environment="longtable",floating=FALSE)
  @
  }%
  
  \def\MoreThanOneSplit{%
<<moreonsplit, echo=FALSE, results='asis'>>=
print(xtable(distrib_2plus_split_per_ct_table, type = "latex"), include.rownames=FALSE, tabular.environment="longtable", floating=FALSE)
      @
  }%
  
  \def\HottestMegamorphic{%
<<hottestmega, echo=FALSE, results='asis'>>=
print(xtable(hottest_mega_ct_table, type = "latex"), include.rownames=FALSE)
    @
  }%
  
  \def\SuperHottestMegamorphic{%
<<superhottestmega, echo=FALSE, results='asis'>>=
print(xtable(hottest_30mega_ct_table, type = "latex"), include.rownames=FALSE)
    @
  }%
  
  \def\MostExecutedCallSite{%
<<mostexecuted, echo=FALSE, results='asis'>>=
print(xtable(most_executed, type = "latex"), include.rownames=TRUE, tabular.environment="longtable",floating=FALSE)
      @
  }%
  
  \def\SplitDistrib{%
<<splidistrib, echo=FALSE, results='asis'>>=
print(xtable(distrib_split_per_ct_table, type = "latex"), include.rownames=FALSE, tabular.environment="longtable",floating=FALSE)
      @
  }%
  
    \def\SummaryPerLookupCache{%
<<sumpercache, echo=FALSE, results='asis'>>=
print(xtable(cachetab, type = "latex"), include.rownames=FALSE)
      @
  }%
  
    
    \def\SummaryPerRubyCallSite{%
<<sumpercall, echo=FALSE, results='asis'>>=
print(xtable(calltab, type = "latex"), include.rownames=FALSE)
      @
  }%

\newcommand{\BenchmarkName}{$\Sexpr{benchmark_name}$\xspace}
\newcommand{\NumIterations}{$\Sexpr{number_iterations}$\xspace}
\newcommand{\NumInnerIterations}{$\Sexpr{number_inner_iterations}$\xspace}
\newcommand{\LogFilename}{\Sexpr{filename}\xspace}

\newcommand{\NumberCallSites}{$\Sexpr{num_call_sites$Cumulative}$\xspace}
\newcommand{\NumberCalls}{$\Sexpr{nrow(total)}$\xspace}
\newcommand{\NumOfSplittedTargets}{$\Sexpr{nrow(split_call_site)}$\xspace}

\newcommand{\NumberPolymorphic}{$\Sexpr{num_poly}$\xspace}
\newcommand{\NumberMegamorphic}{$\Sexpr{num_mega}$\xspace}

\newcommand{\Hihaho}{\Sexpr{hihaho}\xspace}
\newcommand{\Yuria}{\Sexpr{yuria}\xspace}


\newcommand{\HasChangedStatus}{$\Sexpr{Has.Changed.Status}$\xspace}
\newcommand{\HasExperiencedTP}{$\Sexpr{Has.Experienced.TP}$\xspace}






