source("./scripts/libraries.R", chdir=TRUE)

args = commandArgs(trailingOnly=TRUE)
benchmark_name = args[1]
folder_out = args[2]
filename = args[3]

keep_startup = as.logical(args[4])
keep_blocks = as.logical(args[5])

# benchmark_name = "DeltaBlue"
# folder_out = "../results/latest"
# filename = "../results/latest/parsed_DeltaBlue.log"

# keep_startup = TRUE
# keep_blocks = FALSE
# benchmark_name = "Acid"
# folder_out = "../results/11-08-22_18-49-42/Acid/"
# filename = "../results/11-08-22_18-49-42/Acid/parsed_Acid.log"

col_names <- c("Stage", "Symbol", "Original.Receiver", "Source.Section", "CT.Address", "Builtin?", "Observed.Receiver")
data <- fread(filename, header = FALSE, sep="\t", col.names = col_names)
data$Benchmark <- benchmark_name

if (!keep_startup) {
  data <- data[!(`Stage` %like% "STARTUP")] #remove startup data
}

if(!keep_blocks) {
  data <- data[!(`Builtin?` %like% "PROC|LAMBDA|block")] #remove block data
} else {
  data <- data[`Builtin?` %like% "PROC|LAMBDA|block"]
  stop("You should use BLOCK_generate_plots.Rnw instead")
}

data <- data[, na.omit(.SD)][, Call.ID := 1:.N][, lapply(.SD, str_trim)]

first_user <- head(data[Stage == "MAIN"], 1)
first_user <- first_user$Call.ID

gc()

data[ , 
      `:=`(Num.Receiver.Observed = n_distinct(Observed.Receiver), 
           Num.Receiver.Original = n_distinct(Original.Receiver)), by=list(Source.Section, Symbol, Benchmark)]

data[ , 
      `:=`(Split.Num.Receiver.Observed = n_distinct(Observed.Receiver)), by=list(Source.Section, Symbol, CT.Address, Benchmark)]

data[ , "Times.Splitted" := (n_distinct(CT.Address) - 1), by=list(Source.Section, Symbol)]

data[ , "Lookup.Status" := (fcase(
  (Num.Receiver.Original == 1), "MONO",
  ((Num.Receiver.Original  > 1) & (Num.Receiver.Original  <= 8)), "POLY",
  (Num.Receiver.Original > 8), "MEGA"))]

data[ , "TP.Lookup.Status" := (fcase(
  (Num.Receiver.Observed == 1), "MONO",
  ((Num.Receiver.Observed  > 1) & (Num.Receiver.Observed  <= 8)), "POLY",
  (Num.Receiver.Observed > 8), "MEGA"))]

data[ , "Split.Lookup.Status" := (fcase(
  (Split.Num.Receiver.Observed == 1), "MONO",
  ((Split.Num.Receiver.Observed  > 1) & (Split.Num.Receiver.Observed  <= 8)), "POLY",
  (Split.Num.Receiver.Observed > 8), "MEGA"))]

############################################## MANUAL INSPECTION ############################################## 

  # to filter out by the number of targets and only keep polymoprhic call-sites
data[ , "N.Calls" := uniqueN(.SD) , by = list(Source.Section, Symbol, Observed.Receiver)]
data_plot <- data[TP.Lookup.Status != "MONO"]
setorderv(data_plot, c("N.Calls"), order=-1L)

table_optimizable <- unique(data_plot, by = c("Source.Section", "Symbol") )
table_optimizable[, Rank := 1:.N]

############################################## PLOT GENERATION - FACET ##############################################

# this generates a faceted plot, each facet being the target adress(es), for a couple {Source.Section, symbol}
plot_calls <- function(ss, symb) {
  filtered_data <- data %>% filter(Source.Section == ss & Symbol == symb)
  split_callSite <- strsplit(ss, "/", fixed=TRUE)
  p <- ggplot(data = filtered_data, aes(x=as.numeric(as.character(Call.ID)), y=Observed.Receiver, color=Observed.Receiver)) + geom_point(size = 5, alpha = 0.7)
  p <- p + xlab("Time (Call ID)") + ggtitle(paste(filtered_data$Symbol, ", in ", tail(split_callSite[[1]], 1)))
  p <- p  + theme_bw() + theme(legend.position = "none")+ theme(text = element_text(size=30), axis.title.y=element_blank())
  p <- p + geom_vline(xintercept = as.numeric(as.character(first_user)))
 return (p)
}

f <- function(row) {
  ss <- row['Source.Section']
  symbol <- row['Symbol']
  rank <- row['Rank'] # prefix the plot name by the rank for an easier analysis
  p_ <- plot_calls(ss, symbol)
  ss <- gsub("*/","_",ss) # replace the / in the name otherwise the file cannot be created
  ss <- str_trunc(ss, 25, side='left')
  ggsave(p_, path=folder_out, filename=paste(rank,ss,symbol,"plot.png", sep="_"), height = 150, width = 400, units="mm")
}

# 1 line in the table_optimizable corresponds to the most executed observed receiver per target
# We use the table_optimizable as input to know which target to generate a plot for
# we apply the plot_calls method to each of these target
if (nrow(table_optimizable) != 0) {
  apply(head(table_optimizable, 30), 1, f) 
}

############################################## PLOT GENERATION - LIFETIME ##############################################
split_lifetime_folder = file.path(folder_out, "split_lifetime")
if (!dir.exists(split_lifetime_folder)) {
  dir.create(split_lifetime_folder)
}

data_split <- data[Times.Splitted > 0 ]
setorderv(data_split, c("N.Calls", "Times.Splitted"), order=-1L)

data_split <- data_split[ , .(Observed.Receiver = list(unique(Observed.Receiver)), Call.ID), by = list(Source.Section, Symbol, CT.Address)]
setnames(data_split, "Observed.Receiver", "Signature") 

table_optimizable_split <- unique(data_split, by = c("Source.Section", "Symbol") )
table_optimizable_split[, Rank := 1:.N]

# One plot per call-site, where each y variable is an CT Address
# this generates a faceted plot, each facet being the target adress(es), for a couple {Source.Section, symbol}

split_lifetime <- function(ss, symb) {
  filtered_data <- data_split[Source.Section == ss & Symbol == symb]
  filtered_data$CT.Address.num = as.numeric(as.character(filtered_data$CT.Address))
  filtered_data$CT.Address_ord <- factor(filtered_data$CT.Address.num, levels = sort(unique(filtered_data$CT.Address.num)), ordered = TRUE )
  
  p <- ggplot(data = filtered_data, aes(x=as.numeric(as.character(Call.ID)), y=CT.Address_ord, color=as.character(Signature))) + geom_point(size = 0.5, alpha = 0.4) 
  p <- p + xlab("Call ID") + ylab("Target") + ggtitle(paste("Split targets lifetime for Selector: ",filtered_data$Symbol, ", in source: ", filtered_data$Source.Section))
  p <- p + theme(text = element_text(size=10)) 
  p <- p + theme_bw() + theme(
    legend.position = c(.95, .95),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(6, 6, 6, 6)
  )
  p <- p + labs(color = "Target type")
  p <- p + geom_vline(xintercept = as.numeric(as.character(first_user)))
  return (p)
}

f <- function(row) {
  ss <- row['Source.Section']
  symbol <- row['Symbol']
  rank <- row['Rank'] # prefix the plot name by the rank for an easier analysis
  p_ <- split_lifetime(ss, symbol)
  ss <- gsub("*/","_",ss) # replace the / in the name otherwise the file cannot be created
  ss <- str_trunc(ss, 25, side='left')
  ggsave(p_, path=split_lifetime_folder, filename=paste(rank,"splitlifetime",ss,symbol,"plot.png", sep="_"), height = 300, width = 500, units="mm")
}

# 1 line in the table_optimizable corresponds to the most executed observed receiver per target
# We use the table_optimizable as input to know which target to generate a plot for
# we apply the plot_calls method to each of these target
if (nrow(table_optimizable_split) != 0) {
  apply(head(table_optimizable_split, 30), 1, f) 
}
